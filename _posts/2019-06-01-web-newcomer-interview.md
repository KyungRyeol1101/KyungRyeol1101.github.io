---
layout: post
title: "Web 신입 면접 정리"
date: 2019-06-01
excerpt: "Web 신입 면접과 관련하여 정리"
tags: [web, spring, java, programming, mvc, interview]
comments: true
---

## Oracle 클러스터 인덱스와 넌 클러스터 인덱스의 차이
* 클러스터드 인덱스 : 실제 DB의 데이터 파일에 정렬되어 있는 상태로 디스크에 저장이 됨. (테이블당 한개)
* 넌클러스터드 인덱스 : 실제 DB의 데이터 파일에 정렬되지 않는 상태로 디스크에 저장이 됨.

## GET 방식과 POST 방식?
* GET
  * 클라이언트에서 서버로 데이터를 전달할 때, 주소 뒤에 "이름"과 "값"이 결합된 스트링 형태로 전달.
  * 주소창에 쿼리 스트링이 그대로 보여지기 때문에 보안성이 떨어진다.
  * 길이에 제한이 있다.(=전송 데이터의 한계가 있다.)
  * Post 방식보다 상대적으로 전송 속도가 빠르다.
* POST
  * 일정 크기 이상의 데이터를 보내야 할 때 사용한다.
  * 서버로 보내기 전에 인코딩하고, 전송 후 서버에서는 다시 디코딩 작업을 한다.
  * 주소창에 전송하는 데이터의 정보가 노출되지 않아 Get 방식에 비해 보안성이 높다.
  * 속도가 Get 방식보다 느리다.
  * 쿼리스트링(문자열) 데이터 뿐만 아니라, 라디오 버튼, 텍스트 박스 같은 객체들의 값도 전송가능.
* Get과 Post 차이점
  * Get은 주로 웹 브라우저가 웹 서버에 데이터를 요청할 때 사용.
  * Post는 웹 브라우저가 웹 서버에 데이터를 전달하기 위해 사용.
  * Get을 사용하면 웹 브라우저에서 웹 서버로 전달되는 데이터가 인코딩되어 URL에 붙는다.
  * Post 방식은 전달되는 데이터가 보이지 않는다.
  * Get 방식은 전달되는 데이터가 255개의 문자를 초과하면 무넺가 발생할 수 있다.
  * 웹서버에 많은 데이터를 전달하기 위해서는 Post 방식을 사용하는 것이 바람직하다.

## Session과 Cookie
* Session과 Cookie 사용 이유
  * 현재 우리가 인터넷에서 사용하고 있는 HTTP프로토콜은 연결 지향적인 성격을 버렸기 때문에 새로운 페이지를 요청할 때마다 새로운 접속이 이루어지며 이전 페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이에 따라 HTTP프로토콜을 이용하게 되는 웹사이트에서는 웹페이지에 특정 방문자가 머무르고 있는 동안에 그 방문자의 상태를 지속시키기 위해 쿠키와 세션을 이용한다.
* Session
  * 특정 웹사이트에서 사용자가 머무르는 기간 또는 한 명의 사용자의 한번의 방문을 의미한다.
  * Session에 관련된 데이터는 Server에 저장된다.
  * 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제시 사라진다.
  * Cookie에 비해 보안성이 좋다.
* Cookie
  * 사용자 정보를 유지할 수 없다는 HTTP의 한계를 극복할 수 있는 방법.
  * 인터넷 웹 사이트의 방문 기록을 남겨 사용자와 웹 사이트 사이를 매개해 주는 정보이다.
  * Cookie는 인터넷 사용자가 특정 웹서버에 접속할 때, 생성되는 개인 아이디와 비밀번호, 방문한 사이트의 정보를 담은 임시 파일로써, Server가 아닌 Client에 텍스트 파일로 저장되어 다음에 해당 웹서버를 찾을 경우 웹서버에서는 그가 누구인지 어떤 정보를 주로 찾았는지 등을 파악할 때 사용된다.
  * Cookie는 Client PC에 저장되는 정보기 때문에, 다른 사용자에 의해서 임의로 변경이 가능하다.(정보 유출 가능, Session보다 보안성이 낮은 이유)
* 보안성이 낮은 Cookie 대신 Session을 사용하면 되는데 안하는 이유?
  * 모든 정보를 Session에 저장하면 Server의 메모리를 과도하게 사용하게 되어 Server에 무리가 감.

## JDBC
* Java Data Base Connection의 약자로 JAVA 언어를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍의 의미

## Servlet vs JSP
* Servlet : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것.
* JSP : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것.

## Overloading(오버로딩)과 Overriding(오버라이딩)의 차이?
* Overloading(오버로딩)
  * 메서드 명은 동일하지만, 매개 변수 타입과 개수를 다르게 해 선언하는 방식.
  * 같은 이름의 메소드를 여러개 정의하는 것.
  * 매개변수의 타입이 다르거나 개수가 달라야 한다.
  * return type과 접근 제어자는 영향을 주지 않음.
* Overriding(오버라이딩)
  * 상속한 자식에서 부모의 메서드를 재정의하는 방식(부모 클래스의 메소드를 자식 클래스에서 재정의)

## MVC 패턴이란?
* Model : data 처리와 접근을 담당, 소프트웨어 응용과 그와 관련된 고급 클래스 내의 논리적 데이터 기반 구조를 표현, 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.
* View : Client에 보여지는 화면을 담당, 사용자 인터페이스 내의 구성요소들을 표현(사용자에게 보여지는 화면)
* Controller : Model과 View를 제어
하는 3가지 부분으로 나눔으로서, 데이터와 화면 간의 의존관계를 벗어날 수 있게하는 개발 기법.
* 사용자가 보는 페이지, 데이터 처리, 그리고 이 2가지를 중간에서 제어하는 컨트롤, 이 3가지로 구성되는 하나의 애플리케이션을 만들면 각각 맡은 바에만 집중을 할 수 있게 됨.
* 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식 중 하나.
* MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

## 싱글톤(SingleTone Pattern)
* 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식.

## 팩토리 패턴(Factory Pattern)
* 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는 생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식.

## 옵저버 패턴(Observer Pattern)
* 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로 사용.

## Spring의 AOP(관점 지향 프로그래밍)란?
* AOP는 Aspect Oriented Programming  관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트 메서드처럼 공통적으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식으로 이러한 공통 코드를 "횡단 관심사"라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식
* 공통의 관심사항을 적용해서 발생하는 의존관계의 복잡성과 코드 중복을 해소해 주는 프로그래밍 기법. OOP라 하면 관심사가 같은 기능과 데이터를 한데 모아서 객체 지향 설계 원칙에 따라 분리하고, 서로 낮은 결합도를 가진채 독립적이고 유연하게 확장할 수 있는 모듈로 캡슐화 하는 것을 일컫는다. 하지만 대부분의 프로젝트에서는 메소드의 호출 전후의 데이터 확인을 위한 로깅이나 예외처리, 데이터 검증과 관련된 코드가 클래스 전반에 걸쳐서 쓰여지고 있음. OOP 모듈화를 방해. 클래스 여기저기에 반복적으로 나타나서 핵심로직 코드의 가독성이나 확장성, 유지보수 등의 효율을 떨어뜨림. 이렇게 관련된 코드를 한데 모아 모듈화 하여 핵심 로직으로부터 분리하고 개발하는 방식을 AOP
* 장점 : 중복되는 코드 제거, Unit Testing 편의성, 유지보수성 향상

## Spirng에서 IoC(제어의 역전)란?
* 프레임워크가 제어권을 가짐. 객체 생성도 컨테이너가 함. IoC 의존관계를 결정, 설정, 생명주기를 해결하기 위한 디자인 패턴
* IoC가 아닌 경우
{% highlight java %}
String A = new String();
{% endhighlight %}
* IoC인 경우
{% highlight java %}
@Autowired
UserService userService;
{% endhighlight %}
* 객체 생성 생명 주기 관리. 의존성 관리. POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가짐.

### IoC 분류
* DL(의존성 검색(특정 컨테이너에 종속되는 API 사용)) : 저장소에 저장되어 있는 Bean에 접근하기 위해 컨테이너가 제공하는 API를 이용하여 Bean을 조회하는 것. 컨테이너가 제공하는 API를 사용하기 때문에 컨테이너에 종속성이 늘어남.

* DI : 각 클래스간의 의존관계를 Bean설정 정보를 바탕으로 컨테이너가 자동으로 연결시켜주는 것.
** SetterInjection(셋터를 통해 주입)
** Constructor(생성자를 통해 주입)
** Method(자바 메서드를 통해 주입)
* 의존관계 Bean설정(사용자가 설정해줌), 어노테이션 등등이 있다. 컨테이너가 정보들을 읽고 자동으로 설정.
{% highlight java %}
@Autowired // 의존관계 설정
UserService userService;
{% endhighlight %}
* 컨테이너가 흐름의 주체가 된다.(사용자가 설정해준 것을 컨테이너가 연결)
* 장점 : 코드가 단순, 컴포넌트 간의 결합도 제거
* Spring DI 컨테이너가 관리하는 객체를 Bean, 이 Bean들을 관리한다는 의미로 컨테이너를 Bean Factory.
* Spring API에서 BeanFactory 인터페이스 제공.
* BeanFactory에 여러가지 컨테이너 기능을 추가하여 애플리케이션 컨텍스트라고 부름.
* BeanFactory : Bean을 등록, 생성, 조회, 반환 관리한다. 이를 확장한 것이 Application Context.
* Application Context(DI 컨테이너 역할) : Spring의 각종 부가 서비스 추가 제공.

### POJO(특정 규약에 종속되지 않는 자바 객체?)
* 특정 규약에 종속되지 않는다.
* 특정 환경에 종속되지 않는다.
* 객체 지향 원리에 충실해야 한다.

* 사용 이유
  * 코드 간결함.
  * 자동화 테스트에 유리.
  * 객체지향적 설계의 자유로운 사용.

## Spring에서 DI(의존성 주입)란?
* DI는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 IoC 컨테이너의 구체적인 구현 방식, DI는 기존처럼 개발코드 부분에서 객체를 생성하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식. 이 때, Factory 패턴의 Factory Class의 역할을 Spring의 환경설정 파일이 담당.
* 객체 간의 의존관계를 객체 자신이 아닌 외부 조립기가 수행해준다는 개념. DI패턴을 적용할 경우 클래스는 의존하는 객체를 전달받기 위한 설정 메소드다. 생성자를 제공할 뿐 직접 의존하는 클래스를 찾지 않음. 의존하는 객체를 조립기가 삽입해주기 때문에 이 방식을 DI패턴이라고 함. DI패턴 사용시 단위테스트가 가능. 단위테스트는 코드의 품질을 향상시키고 개발속도 증가 시킴. 의존적인 객체를 직접 생성하거나 제어하는 것이 아니라, 특성 객체에 필요한 객체를 외부에서 결정해서 연결시키는 것.

### DAO
* Database의 data에 접근하기 위한 객체

### DTO
* 로직을 가지지 않은 순수 데이터 객체(getter, setter)

## Spirng MVC 처리 순서
1. 클라이언트가 서버에 어떤 요청을 한다면 스프링에서 제공하는 DispatcherServlet이라는 클래스가 요청을 가로챈다.
2. 요청을 가로챈 DispatcherServlet은 HaddlerMapping에게 어떤 컨트롤러에게 요청을 위임하면 좋을지 물어본다.
3. 요청에 매핑된 컨트롤러가 있다면 <code>@RequestMapping</code>을 통하여 요청을 처리할 메서드에 도달한다.
4. 컨트롤러에서는 해당 요청을 처리할 Service를 주입(DI)를 받아 비지니스 로직을 Service에게 위임한다.
5. Service에서는 요청에 필요한 작업 대부분(코딩)을 담당, DB처리는 DAO를 주입 받아 위임한다.
6. DAO는 mybatis 설정을 이용해 SQL쿼리를 날려 DB의 정보를 받아 서비스에게 다시 돌려준다.이 때 보통 VO(DTO)를 컨트롤러에서부터 내려받아 쿼리의 결과를 VO에 담는다.(mybatis의 resulttype)
7. 모든 로직을 끝낸 서비스가 결과를 컨트롤러에게 넘긴다.
8. 결과를 받은 컨트롤러는 Model 객체에 결과물인 어떤 view(jsp) 파일을 보내줄 것인지 등의 정보를 담아 DispatcherServlet에게 보낸다.
9. DispatcherServlet은 ViewResolver에게 받은 뷰의 대한 정보를 넘긴다.
10. ViewResolver는 해당 jsp를 찾아서(응답할 view를 찾음) DispatcherServlet에게 알려준다.(servlet-context.xml에서 suffix, preffix를 통해 /WEB-INF/views/index.jsp 이렇게 만들어주는 것도 ViewResolver)
11. DispatcherServlet은 응답할 view에게 Render를 지시하고 view는 응답 로직을 처리한다.
12. 결과적으로 DispatcherServlet이 클라이언트에게 렌더링된 view를 응답한다.

## 추상메서드? 추상클래스? Interface(인터페이스)?
* 추상메서드 : 메서드의 정의부만 있고 구현부는 있지 않은 메서드
* 추상클래스 : 추상메서드를 적어도 하나 이상 가지고 있는 클래스로 자식클래스에서 오버라이딩(재정의)가 필요한 추상메서드를 가지고 있기 때문에 객체화 할 수 없다.
* Interface(인터페이스)
  * 일종의 추상 클래스.
  * 오직 추상 메서드와 상수만을 멤버로 갖는다.
  * Implements 키워드를 사용.
  * 상속의 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있도록 한다.
  * Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.
* Abstract
  * 추상메서드를 하나 이상 가진 클래스.
  * 자신의 생성자로 객체 생성 불가능.
  * 하위 클래스를 참조하여 상위 클래스의 객체를 생성.
  * 하위 클래스를 제어하기 위해 사용.
* Interface vs Abstract
  * 공통점
    * new 연산자로 인스턴스 생성 불가능.
    * 프로토타입만 있는 메서드를 갖는다.
    * 사용하기 위해서는 하위클래스에서 확장/구현 해야 한다.
  * 차이점
    * 사용하는 키워드가 다르다.
    * Abstract는 일반 메서드를 사용할 수 있지만, Interface는 메서드 선언만 가능하다.

## Call by Reference, Call by Value
* Call by Reference : 매개 변수의 원래 주소에 값을 저장하는 방식, 클래스 객체를 인수로 전달한 경우
* Call by Value : 인수로 기본 데이터형을 사용, 주어진 값을 복사하여 처리하는 방식, 메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않는다.

## Static
* 클래스가 로딩될 때, 메모리 공간을 할다하는데 처음 설정된 메모리 공간이 변하지 않음을 의미.
* 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(객체와 무관한 키워드)

## 캐시(Cache)와 세션(Session)의 공통점과 차이점은?
* 공통점 : 둘 다 사용자의 데이터를 저장
* 캐시 : 캐시는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.
* 세션 : 세션은  서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.

## 프로세스(Process)와 쓰레드(Thread)의 차이점?
* 프로세스 : OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 이 때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에 서로 메모리 공간을 공유하지 못한다. 따라서 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요.
* 쓰레드 : 쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의 자원(메모리)는 프로세스 내에서 공유하기 된다.

## 메모리 영역
* 메서드 영역 : static 변수, 전역변수, 코드에서 사용되는 Class 정보 등이 올라간다. 코드에서 사용되는 Class들을 로더로 읽고 클래스별로 런타임 필드데이터, 메서드 데이터 등을 분류해 저장.
* 스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO(Last In First Out) 방식의 메모리
* 힙(Heap) : new 연산자를 통한 동적할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

## RestFul API
* 해당 UR만 보더라도 바로 어떤 작업을 하는지를 알 수 있도록 하나의 데이터는 하나의 URL을 갖도록 작업하는 방식.

* 규칙
  * 자원
  * 메소드만으로 표현
  * 동사 말고 명사만
  * 확장자는 표시하지 않음

* Get, Put, Post, Delete
* 웹에 존재하는 모든 자원(이미지, 동영상, DB자원)에 고유한 URI를 부여해 활용. 자원을 정의하고 자원에 대한 주소를 지정하는 방법론을 의미. 다양한 Device를 대응하기 위해

## IaaS
* 기업(아마존이나 마소)이 준비해놓은 환경에서 사용자가 선택.
* AWS, EC2, Azure.
* 고객은 OS와 어플리케이션을 직접 관리.
* 관리 측면에서 개발자와 인프라 관리자의 역할 분담.
* 장점 : 고객은 가상 서버 하위의 레벨에 대해서는 고려할 필요가 없다는 점.

## PaaS
* 운영팀이 인프라를 모니터링할 필요가 없음.
* 사용자는 OS, Server 하드웨어, 네트워크 등등을 고려할 필요가 없음.
* 사용자는 어플리케이션 자체에만 집중할 수 있음.
* 우리는 소스코드만 적어서 빌드하는 것이고, 컴파일은 클라우드에서 하며 결과만 가져오는 것.
* 장점 : PaaS의 경우 이미 설치된 미들웨어 위에 코드만 돌리면 되기 때문에 아무래도 관리가 매우 편함.
* 단점 : 기본적으로 어플리케이션과 플랫폼이 함께 제공됨. 어플리케이션이 플랫폼에 종속되어 개발되기 때문에 다른 플랫폼으로의 이동이 어려울 수도 있음.
* ex) Heroku, Google App Engine, IBM Bluemix

## SaaS
* 모든 것을 기업(클라우드)에서 제공함으로 사용자는 별도의 설치나 부담이 필요없이 SW을 사용.
* 장점
  * Public Cloud에 있는 SW를 웹브라우저로 불러와 언제 어디서나 사용.
  * 사용자는 웹만 접속하면 되기 때문에 사용하기 매우 쉽고, 최신 SW업데이트를 빠르게 제공받을 수 있음.
* 단점
  * SaaS의 특성상 반드시 인터넷에 접속할 수 있어야만 사용, 외부의 데이터 노출에 대한 위험.
* ex) 웹메일, 구글 클라우드, 드롭박스 등

## Serverless 아키텍처
### BaaS : Firebase
* 필요한 다양한 기능들(데이터베이스, SNS연동, 파일시스템 등)을 쉽고 빠르게 구현할 수 있게 해주고, 서버도 알아서 확장.
* 백엔드 로직들이 클라이언트 쪽에서 구현해야 함.
* 복잡한 쿼리가 불가능함.

### FaaS : AWS Lambda
* 프로젝트를 여러개의 함수로 쪼개서, 매우 거대하고 분산된 컴퓨팅 자원에 우리가 준비해둔 함수를 등록하고, 이 함수들이 실행되는 횟수 만큼 비용을 내는 방식.
* 어플리케이션이 아닌 함수를 배포하며, 계속 실행되고 있는 것이 아닌, 특정 이벤트가 발생했을 때 실행되며, 실행이 되었다가 작업을 마치며 종료.

## JAVA
* JAVA는 네트워크상에서 쓸 수 있도록 미국의 선 마이크로 시스템즈가 개발한 객체 지향 프로그래밍 언어
* Java의 특징
  * 자바가상머신(JVM)만 설치하면 컴퓨터의 운영체제의 상관없이 작동한다.(즉, 운영체제에 독립적)
  * 기본 자료형을 제외한 모든 요소들이 객체로 표현
  * 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
  * Garbage Collector를 통한 자동적인 메모리 관리
  * 멀티쓰레드(Multi-thread)를 지원

## Garbage Collection(가비지 컬렉션)
* 시스템에서 더이상 사용하지 않는 동적 할당된 메모리 블럭을 찾아 자동으로 다시 사용 가능한 자원으로 회수하는 것으로 시스템에서 가비지 컬렉션을 수행하는 부분을 가비지 컬렉터라 부른다.

## Primitive type과 Reference type
* Primitive type : 변수에 값 자체를 저장.
  * 정수형 : byte, short, int, long
  * 실수형 : float, double
  * 문자형 : char
  * 논리형 : boolean
  * Primitive type은 Wrapper Class를 통해 객체로 변형할 수 있다.
  * 예) int->Integer, char->Character(int와 char르 제외한 Primitive type의 다른 자료형들은 맨 앞 알파벳을 대문자로 바꿔주면 된다. float->Float)
* Reference type : 메모리상에 객체가 있는 위치를 저장.
  * 종류 : Class, Interface, Array 등

## Wrapper Class
* Primitive type으로 표현할 수 있는 간단한 데이터를 객체로 만들어야 할 경우가 있는 그러한 기능을 지원하는 클래스.

## OOP(객체지향 프로그래밍)
* OOP란 Object-Oriented Programming의 약어로써 객체지향 프로그래밍을 의미
* 데이터를 객체로 취급하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는 다르게 객체와 객체의 상호작용을 통해 프로그램이 동작하는 것을 말한다.
* OOP 특징
  * 객체지향 프로그래밍은 코드의 재사용성이 높다.
  * 코드의 변경이 용이
  * 직관적인 코드 분석
  * 개발속도 향상
  * 상속을 통한 장점 극대화

## Object
* Object(객체)는 OOP에 데이터(변수)와 그 데이터에 관련되는 동작(함수). 즉 절차, 방법, 기능을 모두 포함한 개념.
